#### All is as was discussed in class

ADTs
- represent the different ways of organizing data in a computer. 
- each ADt specifies WHAT data is stored and WHAT operations on the data. Not HOW to store and HOW to implement the operations.

Data Structure
- An implementation of an ADT within a programming language.
A data structure is specialized format for organizing, provessing, retrieving and storing data. It is a way to implement an ADT. 
Two types of data structures
1. Stattic data structures
- data is stored in memory and does not change. It is fixed such as the array
2. Dynamic 
- varies in size such as link-list, queue, and stack

Types of DS in most programming languages
- Arrays
- Class/structures
- Strings

Data structures that have to be created
- Lists
- Stacks
- Queues
- Trees
- Graphs
- Hash tables
- Recursive


#### 1. Arrays
- An array is the simplest data structure


#### 2. Linked-list


#### 3. Stack


#### 4. Queue


#### 5. Recursive

#### 6. Tree

#### 7. Graph



### Operations in a Data Structure
- Insertion: adding a new record
- Deletion: removing a record
- Search: finding a record or the location of using a key
- Traversing: visiting each record in the data structure at least once


### Combination
- Updating: 
- Sorting:
- Merging: combining two or more data structures into one

### Alogrithm
- A set of instructions that can be performed on a data structure to solve a problem. They involve input --> processing --> output.
- Data structure + Algorithm --> Program


### Types of Algos
### 1. Brute Force
Brute force is a method where you solve a problem by trying all possible solutions and picking the best one. It doesn't use any shortcuts and simply checks every option. For example, if you want to find the largest number in a list, you would check each number to determine the largest. This approach is useful for small problems or when you're unsure how else to solve it.

---

### 2. Divide and Conquer
Divide and conquer is a technique where a problem is split into smaller parts, each part is solved independently, and the results are combined. An example of this is Merge Sort, where a list is split into halves, each half is sorted, and the halves are then merged back together in order. This method works well when the problem can be broken down into smaller, independent problems.

---

### 3. Recursive Algorithm
A recursive algorithm is one where a function calls itself to solve a problem. The function typically solves a smaller part of the problem and then calls itself to handle the remaining part. For example, calculating the factorial of a number involves calling the factorial function on smaller numbers, like `5! = 5 * 4!`. This method is useful for problems with repetitive sub-problems, like in trees or linked lists.

---

### 4. Greedy Algorithm
A greedy algorithm solves a problem step-by-step, always picking the best option at each step. The idea is to make the locally optimal choice at each stage, hoping it leads to the globally optimal solution. An example is Dijkstra's algorithm for finding the shortest path in a graph, where at each step, the closest node is chosen. This works well when making the best choice now leads to
